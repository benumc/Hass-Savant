<?xml version="1.0" encoding="UTF-8"?>
<component xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="racepoint_component_profile.xsd" manufacturer="Hass" model="WS" alias="Home Assistant"
  device_class="Lighting_controller" minimum_component_engine_version="0" rpm_xml_version="2.7">

  <notes>
    Version 2.7: Complete feedback re-write. Now uses a comma separated list to ignore or include keys for feedback based on a state variable. "all" followed by any other keys will allow all keys except any specified after all. Otherwise will ignore all keys except those in the list. Default is "brightness,state"
    Version 2.6: Adjusted feedback scaling to 0-255
    Version 2.5: More data filtering and added support for service call handling. Removed tracking for grouped entites as these should receive their own updates.
    Version 2.4: Further reduced incoming data and added initial state gathering. Limited group support. Still need to support more entity types
    Version 2.3: Status Feedback Overhaul to filter down closer to useful information. Still needs quite a bit of work.
    Version 2.2: Limited parsing for incoming data and required userzone needed in state variables section.
    Version 2.1: Fix protocol error in websocket handshake
    
    ToDo. Add support for all savant supported entities.
      Dimmer(working), Switch(Working), Button(generic states only as call service), Thermostat(generic states only), fans(generic states only), garage door, door lock etc.
    
    ToDo Optional
      Could replace install script with two other profiles to reduce complexity and startup time and reduce the chances of a startup loop. Not sure which is better or easier for average user.
    
    Setup
    Must set address on the wire to the host ip address
    hass (ip address or hostname) and token need to be set in the state variables section
    
    Keep in mind that this is written with only a virtual home assistant system and feedback from those that try it. 
    Improvements can only be made when issues are well described and preferably include output from rpmterminal when possible.
    The co-processor script also includes a log file on the host at ~/hass_ws.log.
    
    If you run into problems getting the profile to connect, try the following:
    1) Wait a few minutes after the system has come online. The profile goes through several steps to install the communication co-processor and on smart hosts especially this can take some time.
    2) Double check that your long lived access token and hass (ip address or hostname) are set correctly in the state variables section. If using hostname then make sure that the savant host is on the same subnet as the hass serever and it can communicate with the hass server using its hostname.
    3) Make sure that the IP Address on the wire in blueprint is set to the IP ADDRESs of THE SAVANT HOST. This is critical for the installation script to run.
    
    If still having trouble, try setting the user_zone state variable on the component to exactly match a short userzone in your config like Pool or Den. This can be important, especially for smart hosts with many user zones. When the start-up script runs by default, it will execute once for every zone that exists in the project. On a pro host this probably isn't a big deal but setting the value correctly will always improve performance at any reboot or upload.
    A couple more notes about the user_zone state:
    If the name of the zone is too long then the startup script could fail.
    If the General Programmable Service Requests service has been disabled in the zone that is entered, then the script won't run.
    If the General Programmable Service Requests service has been disabled in all zones then the script can't ever run.
    If the General Programmable Service Requests service is only enabled in a single zone then the user_zone state can be left blank.
    
  </notes>
  <component_properties>
    <listen_for_third_party_service_requests>true</listen_for_third_party_service_requests><!--_run_once_-->
  </component_properties>
  
  <control_interfaces preferred="ip">
    <ip port="25804" response_time_length_ms="1000" protocol="udp" local_port="25804"><!--_run_once_-->
      <!--_run_after_<ip port="25804" response_time_length_ms="10000" protocol="tcp">-->
      <!--_run_after_<send_postfix type="hex">0A</send_postfix>-->
      <receive_end_condition test_condition="data" type="hex">0A</receive_end_condition>
    </ip>
  </control_interfaces>
  <media_interfaces>
    <data name_on_component="Ethernet">
      <combined_media>
        <data_media type="ethernet"/>
        <control port="25804"/>
      </combined_media>
    </data>


    <internal name_on_component="Lighting Controller">
      <environmental_media/>
      <resource resource_type="ENV_LIGHTINGCONTROLLER_SOURCE"/>
      <resource resource_type="ENV_FANCONTROLLER_SOURCE"/>
    </internal>
    <internal name_on_component="DoorLockController">
      <environmental_media/>
      <resource resource_type="ENV_DOOR_LOCK_SOURCE"/>
    </internal>
    <internal name_on_component="GarageDoorController">
      <environmental_media/>
      <resource resource_type="ENV_GARAGE_DOOR_SOURCE"/>
    </internal>
  </media_interfaces>
  <state_variable_list>
    <state_variable name="auth_token" owning_logical_component="Home Assistant" state_center_type="string" user_editable="yes" note="Long Lived User Access Token"/>
    <state_variable name="server_fqdn" owning_logical_component="Home Assistant" state_center_type="string"/>
    <state_variable name="server_address" owning_logical_component="Home Assistant" state_center_type="string" user_editable="yes" note="Hass Server Address">homeassistant.local</state_variable>
    <state_variable name="server_port" owning_logical_component="Home Assistant" state_center_type="string" user_editable="yes" note="Hass Server API Port">8123</state_variable>

    <state_variable name="FanSet_0" owning_logical_component="Home Assistant" state_center_type="string" user_editable="yes" note="Fan Speed Off">0</state_variable>
    <state_variable name="FanSet_1" owning_logical_component="Home Assistant" state_center_type="string" user_editable="yes" note="Fan Speed Low">2</state_variable>
    <state_variable name="FanSet_2" owning_logical_component="Home Assistant" state_center_type="string" user_editable="yes" note="Fan Speed Mid">4</state_variable>
    <state_variable name="FanSet_3" owning_logical_component="Home Assistant" state_center_type="string" user_editable="yes" note="Fan Speed High">7</state_variable>


    <state_variable name="profile_name" owning_logical_component="CoProcessor" state_center_type="string" state_center_binding="profile_name">hass_ws</state_variable>
    <state_variable name="user_zone" owning_logical_component="CoProcessor" state_center_type="string" state_center_binding="user_zone" user_editable="yes"></state_variable>
    <state_variable name="prefix" owning_logical_component="CoProcessor" state_center_type="string" state_center_binding="prefix" user_editable="yes">---1-SVC_GEN_GENERIC-RunCLIProgram:COMMAND_STRING=</state_variable>

    <state_variable name="state_filter" owning_logical_component="CoProcessor"  state_center_type="string" state_center_binding="state_filter" user_editable="yes">brightness,state</state_variable>
  </state_variable_list>
  <logical_component logical_component_name="Home Assistant">
    <implementation>
      <internal name_on_component="Lighting Controller"/>
    </implementation>

    <status_messages>
      <status_message name="Brightness2">
        <constant type="character">2|</constant>
        <data type="character" terminator="|" terminator_type="character">
          <update state="EntityID" type="string" />
        </data>
        <constant type="character">new_state|attributes|brightness|</constant>
        <data type="character" terminator_type="end_of_data">
          <update state="Value" type="integer" />
          <data_map match_required="no">
            <convert>
              <multiply>100</multiply>
              <divide>255</divide>
              <update state="DimmerLevel" type="integer"></update>
            </convert>
          </data_map>
        </data>
        <append_data_to_state_names state="EntityID" />
      </status_message>

      <status_message name="Brightness1">
        <constant type="character">1|</constant>
        <data type="character" terminator="|" terminator_type="character">
          <update state="EntityID" type="string" />
        </data>
        <constant type="character">attributes|brightness|</constant>
        <data type="character" terminator_type="end_of_data">
          <update state="Value" type="integer" />
          <data_map match_required="no">
            <convert>
              <multiply>100</multiply>
              <divide>255</divide>
              <update state="DimmerLevel" type="integer"></update>
            </convert>
          </data_map>
        </data>
        <append_data_to_state_names state="EntityID" />
      </status_message>

      <status_message name="State1">
        <constant type="character">1|</constant>
        <data type="character" terminator="|" terminator_type="character">
          <update state="EntityID" type="string" />
        </data>
        <constant type="character">new_state|state|</constant>
        <data type="character" terminator_type="end_of_data">
          <update state="CurrentState" type="string"/>
          <data_map match_required="no">
            <map key="on">
              <update state="IsDimmerOn" type="boolean">true</update>
              <update state="LightPowerStatus" type="string">ON</update>
              <update state="IsLightOn" type="boolean">true</update>
              <update state="DoorLockStatus" type="string">Unlocked</update>
              <update state="GarageDoorStatus" type="string">Open</update>
            </map>
            <map key="off">
              <update state="IsDimmerOn" type="boolean">false</update>
              <update state="LightPowerStatus" type="string">OFF</update>
              <update state="IsLightOn" type="boolean">false</update>
              <update state="DoorLockStatus" type="string">Locked</update>
              <update state="GarageDoorStatus" type="string">Closed</update>
              <update state="DimmerLevel" type="integer">0</update>
            </map>
          </data_map>
        </data>
        <append_data_to_state_names state="EntityID" />
      </status_message>

      <status_message name="State0">
        <constant type="character">0|</constant>
        <data type="character" terminator="|" terminator_type="character">
          <update state="EntityID" type="string" />
        </data>
        <constant type="character">state|</constant>
        <data type="character" terminator_type="end_of_data">
          <update state="CurrentState" type="string"/>
          <data_map match_required="no">
            <map key="on">
              <update state="IsDimmerOn" type="boolean">true</update>
              <update state="LightPowerStatus" type="string">ON</update>
              <update state="IsLightOn" type="boolean">true</update>
              <update state="DoorLockStatus" type="string">Unlocked</update>
              <update state="GarageDoorStatus" type="string">Open</update>
            </map>
            <map key="off">
              <update state="IsDimmerOn" type="boolean">false</update>
              <update state="LightPowerStatus" type="string">OFF</update>
              <update state="IsLightOn" type="boolean">false</update>
              <update state="DoorLockStatus" type="string">Locked</update>
              <update state="GarageDoorStatus" type="string">Closed</update>
              <update state="DimmerLevel" type="integer">0</update>
            </map>
          </data_map>
        </data>
        <append_data_to_state_names state="EntityID" />
      </status_message>

      <status_message name="Depth4">
        <constant type="character">4|</constant>
        <data type="character" terminator="|" terminator_type="character">
          <update state="EntityID" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key0" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key1" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key2" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key3" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key4" type="string" />
        </data>
        <data type="character" terminator_type="end_of_data">
          <update state="Value" type="string" />
        </data>
        <append_data_to_state_names state="EntityID" />
        <append_data_to_state_names state="Key0" />
        <append_data_to_state_names state="Key1" />
        <append_data_to_state_names state="Key2" />
        <append_data_to_state_names state="Key3" />
        <append_data_to_state_names state="Key4" />
      </status_message>

      <status_message name="Depth3">
        <constant type="character">3|</constant>
        <data type="character" terminator="|" terminator_type="character">
          <update state="EntityID" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key0" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key1" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key2" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key3" type="string" />
        </data>
        <data type="character" terminator_type="end_of_data">
          <update state="Value" type="string" />
        </data>
        <append_data_to_state_names state="EntityID" />
        <append_data_to_state_names state="Key0" />
        <append_data_to_state_names state="Key1" />
        <append_data_to_state_names state="Key2" />
        <append_data_to_state_names state="Key3" />
      </status_message>

      <status_message name="Depth2">
        <constant type="character">2|</constant>
        <data type="character" terminator="|" terminator_type="character">
          <update state="EntityID" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key0" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key1" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key2" type="string" />
        </data>
        <data type="character" terminator_type="end_of_data">
          <update state="Value" type="string" />
        </data>
        <append_data_to_state_names state="EntityID" />
        <append_data_to_state_names state="Key0" />
        <append_data_to_state_names state="Key1" />
        <append_data_to_state_names state="Key2" />
      </status_message>

      <status_message name="Depth1">
        <constant type="character">1|</constant>
        <data type="character" terminator="|" terminator_type="character">
          <update state="EntityID" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key0" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key1" type="string" />
        </data>
        <data type="character" terminator_type="end_of_data">
          <update state="Value" type="string" />
        </data>
        <append_data_to_state_names state="EntityID" />
        <append_data_to_state_names state="Key0" />
        <append_data_to_state_names state="Key1" />
      </status_message>
      <status_message name="Depth0">
        <constant type="character">0|</constant>
        <data type="character" terminator="|" terminator_type="character">
          <update state="EntityID" type="string" />
        </data>
        <data type="character" terminator="|" terminator_type="character">
          <update state="Key0" type="string" />
        </data>
        <data type="character" terminator_type="end_of_data">
          <update state="Value" type="string" />
        </data>
        <append_data_to_state_names state="EntityID" />
        <append_data_to_state_names state="Key0" />
      </status_message>

      <status_message name="Service">
        <constant type="character">type:</constant>
        <data type="character" terminator="," terminator_type="character">
          <update state="Type" type="string" />
        </data>
        <constant type="character">entity:</constant>
        <data type="character" terminator="," terminator_type="character">
          <update state="EntityID" type="string" />
        </data>
        <constant type="character">service:</constant>
        <data type="character" terminator="," terminator_type="character">
          <update state="ServiceState" type="string"/>
        </data>
        <constant type="character">domain:</constant>
        <data type="character" terminator="," terminator_type="end_of_data">
          <update state="FriendlyName" type="string"/>
        </data>
        <append_data_to_state_names state="EntityID" />
      </status_message>

      <status_message name="Unhandled">
        <data type="character" terminator_type="end_of_data">
          <update state="Unhandled" type="string"></update>
        </data>
      </status_message>
    </status_messages>

    <resource_component_actions resource_type="ENV_FANCONTROLLER_SOURCE">
      <action name="FanSet">
        <action_argument name="Address1" note="Entity ID"/>
        <action_argument name="Address2" note="not used"/>
        <action_argument name="Address3" note="not used"/>
        <action_argument name="Address4" note="not used"/>
        <action_argument name="Address5" note="not used"/>
        <action_argument name="Address6" note="not used"/>
        <action_argument name="FanSpeed" note="Fan Speed 0 - 3"/>
        <command_interface interface="ip">
          <!-- Can sequence multiple commands, maybe to turn it off when FanSpeed is 0? -->
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="character">curl-d '</parameter>
              <parameter parameter_data_type="character">{"entity_id": "</parameter>
              <parameter parameter_data_type="character" action_argument="Address1"/>
              <parameter parameter_data_type="character">", "speed": "</parameter>
              <parameter parameter_data_type="character" state_variable="FanSet_*" wildcard_source="action_argument" wildcard_source_name="FanSpeed"/>
              <parameter parameter_data_type="character">"}' '</parameter>
              <parameter parameter_data_type="character" state_variable="server_fqdn"/>
              <parameter parameter_data_type="character">/api/services/fan/turn_on</parameter>
              <parameter parameter_data_type="character">'</parameter>
            </parameter_list>
            <delay ms_delay="500"/>
          </command>
        </command_interface>
      </action>

      <entity name="Fan" address_components="2">
        <slider_representation>
          <press_action name="FanSet"/>
          <valueSource name="CurrentDimmerLevel">
            <unique_identifier name="Needed" address_component="2"/>
            <unique_identifier name="DeviceID" address_component="1"/>
          </valueSource>
        </slider_representation>
      </entity>
    </resource_component_actions>

    <resource_component_actions resource_type="ENV_LIGHTINGCONTROLLER_SOURCE">
      <action name="SwitchOn">
        <action_argument name="Address1" note="Entity ID"/>
        <action_argument name="Address2" note="Savant ID"/>
        <action_argument name="Address3" note=""/>
        <action_argument name="Address4" note=""/>
        <action_argument name="Address5" note=""/>
        <action_argument name="Address6" note=""/>
        <command_interface interface="ip">
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="character">sock{"type":"call_service","domain":"light","service":"turn_on","service_data":{"entity_id":"</parameter>
              <parameter parameter_data_type="character" action_argument="Address1"/>
              <parameter parameter_data_type="character">"}}</parameter>
            </parameter_list>
            <delay ms_delay="250"/>
          </command>
        </command_interface>
      </action>

      <action name="SwitchOff">
        <action_argument name="Address1" note="Entity ID"/>
        <action_argument name="Address2" note="Savant ID"/>
        <action_argument name="Address3" note=""/>
        <action_argument name="Address4" note=""/>
        <action_argument name="Address5" note=""/>
        <action_argument name="Address6" note=""/>
        <command_interface interface="ip">
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="character">sock{"type":"call_service","domain":"light","service":"turn_off","service_data":{"entity_id":"</parameter>
              <parameter parameter_data_type="character" action_argument="Address1"/>
              <parameter parameter_data_type="character">"}}</parameter>
            </parameter_list>
            <delay ms_delay="250"/>
          </command>
        </command_interface>
      </action>

      <action name="DimmerSet">
        <action_argument name="Address1" note="Entity ID"/>
        <action_argument name="Address2" note="not used"/>
        <action_argument name="Address3" note="not used"/>
        <action_argument name="Address4" note="not used"/>
        <action_argument name="Address5" note="not used"/>
        <action_argument name="Address6" note="not used"/>
        <action_argument name="DimmerLevel" note="Select the Dimmer Level 0 - 100"/>
        <action_argument name="DelayTime" note="not used"/>
        <action_argument name="FadeTime" note="not used"/>
        <command_interface interface="ip">
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="character">sock{"type":"call_service","domain":"light","service":"turn_on","service_data":{"entity_id":"</parameter>
              <parameter parameter_data_type="character" action_argument="Address1"/>
              <parameter parameter_data_type="character">", "brightness_pct": "</parameter>
              <parameter parameter_data_type="character" action_argument="DimmerLevel"/>
              <parameter parameter_data_type="character">"}}</parameter>
            </parameter_list>
            <delay ms_delay="250"/>
          </command>
        </command_interface>
      </action>

      <entity name="Dimmer Group" address_components="1">
        <slider_representation>
          <press_action name="DimmerSet"/>
          <valueSource name="DimmerLevel">
            <unique_identifier address_component="1" name="Address1" format="%s"/>
          </valueSource>
        </slider_representation>
      </entity>

      <entity name="Switch" address_components="1">
        <toggle_button_representation>
          <release_action name="SwitchOn"> </release_action>
          <toggle_release_action name="SwitchOff"> </toggle_release_action>
          <osd_press_action name="SwitchOn"> </osd_press_action>
          <osd_hold_action name="SwitchOff"> </osd_hold_action>
          <toggleOnUsingState name="IsLightOn">
            <unique_identifier name="Address1" address_component="1" format="%s"/>
          </toggleOnUsingState>
        </toggle_button_representation>
      </entity>
    </resource_component_actions>

    <resource_component_actions resource_type="ENV_DOOR_LOCK_SOURCE">
      <action name="LockDoorLock">
        <action_argument name="DoorLockAddress" note="Entity ID"/>
        <update_state_variable name="DoorLockStatus_*" update_type="set" update_source="constant" wildcard_format="%s" wildcard_source="action_argument" wildcard_source_name="DoorLockAddress">Locked</update_state_variable>
        <update_state_variable name="IsDoorLocked_*" update_type="set" update_source="constant" wildcard_format="%s" wildcard_source="action_argument" wildcard_source_name="DoorLockAddress">true</update_state_variable>
        <command_interface interface="ip">
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="character">curl-d '</parameter>
              <parameter parameter_data_type="character">{"entity_id": "</parameter>
              <parameter parameter_data_type="character" action_argument="DoorLockAddress"/>
              <parameter parameter_data_type="character">"}' '</parameter>
              <parameter parameter_data_type="character" state_variable="server_fqdn"/>
              <parameter parameter_data_type="character">/api/services/lock/lock</parameter>
              <parameter parameter_data_type="character">'</parameter>
            </parameter_list>
            <delay ms_delay="500"/>
          </command>
        </command_interface>
      </action>

      <action name="UnlockDoorLock">
        <action_argument name="DoorLockAddress" note="Entity ID"/>
        <update_state_variable name="DoorLockStatus_*" update_type="set" update_source="constant" wildcard_format="%s" wildcard_source="action_argument" wildcard_source_name="DoorLockAddress">Unlocked</update_state_variable>
        <update_state_variable name="IsDoorLocked_*" update_type="set" update_source="constant" wildcard_format="%s" wildcard_source="action_argument" wildcard_source_name="DoorLockAddress">false</update_state_variable>
        <command_interface interface="ip">
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="character">curl-d '</parameter>
              <parameter parameter_data_type="character">{"entity_id": "</parameter>
              <parameter parameter_data_type="character" action_argument="DoorLockAddress"/>
              <parameter parameter_data_type="character">"}' '</parameter>
              <parameter parameter_data_type="character" state_variable="server_fqdn"/>
              <parameter parameter_data_type="character">/api/services/lock/unlock</parameter>
              <parameter parameter_data_type="character">'</parameter>
            </parameter_list>
            <delay ms_delay="500"/>
          </command>
        </command_interface>
      </action>

      <entity name="Lock" address_components="2">
        <toggle_button_representation>
          <release_action name="UnlockDoorLock"/>
          <toggle_release_action name="LockDoorLock"/>
        </toggle_button_representation>
      </entity>
    </resource_component_actions>

    <resource_component_actions resource_type="ENV_GARAGE_DOOR_SOURCE">
      <action name="CloseGarageDoor">
        <action_argument name="GarageDoorAddress" note="Entity ID"/>
        <update_state_variable name="GarageDoorStatus_*" update_type="set" update_source="constant" wildcard_format="%s" wildcard_source="action_argument" wildcard_source_name="GarageDoorAddress">Closed</update_state_variable>
        <command_interface interface="ip">
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="character">curl-d '</parameter>
              <parameter parameter_data_type="character">{"entity_id": "</parameter>
              <parameter parameter_data_type="character" action_argument="GarageDoorAddress"/>
              <parameter parameter_data_type="character">"}' '</parameter>
              <parameter parameter_data_type="character" state_variable="server_fqdn"/>
              <parameter parameter_data_type="character">/api/services/cover/close_cover</parameter>
              <parameter parameter_data_type="character">'</parameter>
            </parameter_list>
          </command>
        </command_interface>
      </action>

      <action name="OpenGarageDoor">
        <action_argument name="GarageDoorAddress" note="Entity ID"/>
        <update_state_variable name="GarageDoorStatus_*" update_type="set" update_source="constant" wildcard_format="%s" wildcard_source="action_argument" wildcard_source_name="GarageDoorAddress">Open</update_state_variable>
        <command_interface interface="ip">
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="character">curl-d '</parameter>
              <parameter parameter_data_type="character">{"entity_id": "</parameter>
              <parameter parameter_data_type="character" action_argument="GarageDoorAddress"/>
              <parameter parameter_data_type="character">"}' '</parameter>
              <parameter parameter_data_type="character" state_variable="server_fqdn"/>
              <parameter parameter_data_type="character">/api/services/cover/open_cover</parameter>
              <parameter parameter_data_type="character">'</parameter>
            </parameter_list>
          </command>
        </command_interface>
      </action>

      <entity name="Garage Door" address_components="1">
        <toggle_button_representation>
          <release_action name="OpenGarageDoor"/>
          <toggle_release_action name="CloseGarageDoor"/>
        </toggle_button_representation>
      </entity>
    </resource_component_actions>

    <custom_component_actions>
      <action name="QueryLightState">
        <action_argument name="Address1" note="Entity ID"/>
        <command_interface interface="ip">
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="character">tabl</parameter>
              <parameter parameter_data_type="character" action_argument="Address1"/>
            </parameter_list>
            <delay ms_delay="250"/>
          </command>
        </command_interface>
      </action>

      <action name="QueryGarageDoorState">
        <action_argument name="GarageDoorAddress" note="Entity ID"/>
        <command_interface interface="ip">
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="character">curl'</parameter>
              <parameter parameter_data_type="character" state_variable="server_fqdn"/>
              <parameter parameter_data_type="character">/api/states/</parameter>
              <parameter parameter_data_type="character" action_argument="GarageDoorAddress"/>
              <parameter parameter_data_type="character">'</parameter>
            </parameter_list>
            <delay ms_delay="250"/>
          </command>
        </command_interface>
      </action>

      <action name="QueryDoorLockState">
        <action_argument name="DoorLockAddress" note="Entity ID"/>
        <command_interface interface="ip">
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="character">curl'</parameter>
              <parameter parameter_data_type="character" state_variable="server_fqdn"/>
              <parameter parameter_data_type="character">/api/states/</parameter>
              <parameter parameter_data_type="character" action_argument="DoorLockAddress"/>
              <parameter parameter_data_type="character">'</parameter>
            </parameter_list>
            <delay ms_delay="250"/>
          </command>
        </command_interface>
      </action>

      <action name="QueryFanState">
        <action_argument name="Address1" note="Entity ID"/>
        <action_argument name="Address2" note="not used"/>
        <action_argument name="Address3" note="not used"/>
        <action_argument name="Address4" note="not used"/>
        <action_argument name="Address5" note="not used"/>
        <action_argument name="Address6" note="not used"/>
        <update_state_variable name="CurrentLightNumber" update_type="set" update_source="action_argument">Address1</update_state_variable>
        <command_interface interface="ip">
          <command response_required="yes">
            <parameter_list>
              <parameter parameter_data_type="character">curl'</parameter>
              <parameter parameter_data_type="character" state_variable="server_fqdn"/>
              <parameter parameter_data_type="character">/api/states/</parameter>
              <parameter parameter_data_type="character" action_argument="Address1"/>
              <parameter parameter_data_type="character">'</parameter>
            </parameter_list>
            <response_codes>
              <rspmessage status="success" name="HassLightOn">
                <constant type="character">200</constant>
                <root_object name="none" matches_required="at_least_one" format="json">
                  <values path="/state" matches_required="at_least_one">
                    <value_map match_required="yes">
                      <map key="off">
                        <update state="LightPowerStatus" type="string">OFF</update>
                        <update state="IsLightOn" type="boolean">false</update>
                      </map>
                      <map key="on">
                        <update state="LightPowerStatus" type="string">ON</update>
                        <update state="IsLightOn" type="boolean">true</update>
                      </map>
                    </value_map>
                  </values>
                </root_object>
                <append_data_to_state_names state="CurrentLightNumber"/>
              </rspmessage>
            </response_codes>
            <delay ms_delay="50"/>
          </command>
        </command_interface>
      </action>
      <action name="StartUp">
        <!--_run_after_<execute_on_schedule period_ms="0"></execute_on_schedule>-->
        <execute_action_after_delay ms_delay="10000" action_name="ConnectWebsocket" action_type="CUSTOM" use_polling_queue="false" clear_duplicated="false"></execute_action_after_delay>
        <execute_action_after_delay ms_delay="15000" action_name="SubscribeEvents" action_type="CUSTOM" use_polling_queue="false" clear_duplicated="false"/>
      </action>
      <action name="ConnectWebsocket">
        <update_state_variable name="server_fqdn" update_type="set" update_source="constant">http://</update_state_variable>
        <update_state_variable name="server_fqdn" update_type="append" update_source="state_variable">server_address</update_state_variable>
        <update_state_variable name="server_fqdn" update_type="append" update_source="constant">:</update_state_variable>
        <update_state_variable name="server_fqdn" update_type="append" update_source="state_variable">server_port</update_state_variable>
        <command_interface interface="ip">
          <command response_required="no">
            <command_string type="character">scon</command_string>
            <parameter_list>
              <parameter parameter_data_type="character" state_variable="server_fqdn" />
              <parameter parameter_data_type="character">,</parameter>
              <parameter parameter_data_type="character" state_variable="auth_token" />
              <parameter parameter_data_type="character">,</parameter>
              <parameter parameter_data_type="character" state_variable="state_filter" />
            </parameter_list>
          </command>
        </command_interface>
      </action>
      <action name="SubscribeEvents">
        <command_interface interface="ip">
          <command response_required="no">
            <command_string type="character">sock{"type": "subscribe_events"}</command_string>
          </command>
        </command_interface>
      </action>
    </custom_component_actions>
  </logical_component>
  <logical_component logical_component_name="CoProcessor">
    <implementation/>
    <custom_component_actions>
      <action name="START">
        <command_interface interface="ip">
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="hex">0A</parameter>
              <parameter parameter_data_type="character" state_variable="user_zone"/>
              <parameter parameter_data_type="character" state_variable="prefix"/>
              <parameter parameter_data_type="character">grep -A9999 'env </parameter>
              <parameter parameter_data_type="character">ruby' "$(echo ~/*/*/*g.r*/*/hass_ws.xml)"|ruby</parameter>
              <parameter parameter_data_type="hex">0A</parameter>
            </parameter_list>
            <delay ms_delay="3000"/>
          </command>
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="hex">0A</parameter>
              <parameter parameter_data_type="character" state_variable="user_zone"/>
              <parameter parameter_data_type="character" state_variable="prefix"/>
              <parameter parameter_data_type="character">grep -A9999 'env </parameter>
              <parameter parameter_data_type="character">ruby' "$(echo ~/*/*/*/*g.r*/*/hass_ws.xml)"|ruby</parameter>
              <parameter parameter_data_type="hex">0A</parameter>
            </parameter_list>
            <delay ms_delay="3000"/>
          </command>
          <command response_required="no">
            <parameter_list>
              <parameter parameter_data_type="hex">0A</parameter>
              <parameter parameter_data_type="character" state_variable="user_zone"/>
              <parameter parameter_data_type="character" state_variable="prefix"/>
              <parameter parameter_data_type="character">grep -A9999 'env </parameter>
              <parameter parameter_data_type="character">ruby' "$(echo ~/*/*/*/*/*g.r*/*/hass_ws.xml)"|ruby</parameter>
              <parameter parameter_data_type="hex">0A</parameter>
            </parameter_list>
            <delay ms_delay="2000"/>
          </command>
        </command_interface>
        <execute_on_schedule period_ms="0"/><!--_run_once_-->
        <execute_on_schedule period_ms="30000"/><!--_run_once_-->
      </action>
    </custom_component_actions>
  </logical_component>

</component>
<!--[CDATA[






#!/usr/bin/env ruby
###################################################Set Globals###########################################
DEBUG = true
READ_TIMEOUT = 0.5
PORT = 25804

require 'socket'
include Socket::Constants
require 'logger'
require 'json'
require 'base64'
require 'uri'



def program_loop(profile_server)
  $l.debug [profile_server,:on,PORT]
  profile = nil
  headers = ''
  server = ''
  loop do
    hass = nil 
    socks = profile_server.socks
    socks << profile_server
    loop do
      # $l.debug [:listen_on,socks]
      ready = select(socks,nil,nil,30)
      raise 'no connection from savant after 30 seconds. exiting' unless ready
      ready[0].each do |r|
        case r
        when profile_server
          profile_server.accept
          
        when hass
          d = hass.read_data
          # $l.debug d
          m = JSON.parse(d)
          next unless m

          case m['type']
          when 'event'
            m = hass.parse_event(m['event'])
          when 'result'
            m = hass.parse_result(m)
          when 'pong'
            m = 'pong'
          when 'auth_required'
            next
          else
            next
          end
          next unless m
          profile.puts_message(m)

        else
          profile = r
          message = r.gets("\n").chomp
          $l.debug [:from_savant,message]

          case message[0..3]
          when 'scon'
            socks.delete(hass)
            server, tokn, *$filter = message[4..-1].split(',')
            $l.debug [:ws_connect, server, tokn, $filter]
            hass = Hass.new(server,tokn)
            socks << hass
            headers = "-H 'Content-Type: application/json' -H 'Authorization: Bearer #{tokn}'"
            hass.send_data({'type'=>'get_states'})
          when 'curl'
            next if headers == ''
            m = "curl -s #{headers} #{message[4..-1]}"
            $l.debug [:sending, m]
            r.puts_message `#{m}`
            
          when 'sock'
            raise 'Hass websocket not connected' unless hass
            hass.send_data(message[4..-1])

          end
          
        end
      end
    end
  end
rescue => e
  $l.error [e,e.backtrace]
  exit
ensure
  profile_server.close if profile_server rescue nil
end



##########################################Helper Classes#####################################

class Hass < Socket
  
  def initialize(hass_address,token)
    $l.debug [:connecting_to, hass_address]
    super(AF_INET, SOCK_STREAM, 0)
    
    
    @hass_address = URI(hass_address)
    @hass_host = @hass_address.hostname
    @hass_port = @hass_address.port
    @hass_addr = Socket.sockaddr_in(@hass_port, @hass_host)
    
    @id = 0
    @buffer = {}
    
    hass_connect
    hs = make_handshake
    self.print(hs)
    establish_websock(token)
    
  end
  
  def send_data(data)
    data = JSON.parse(data) unless data.is_a?(Hash)
    data['id'] = @id
    send_text(data.to_json)
  end

  def read_data(buffer="")
    fin, opcode, payload = read_frame
    #return buffer unless fin
    case opcode
    when 0x0 # continuation frame
      if fin
        return buffer + payload
      else
        return read_data(buffer + payload)
      end
    when 0x1 # text frame
      if fin
        return buffer + payload
      else
        return read_data(buffer + payload)
      end
    else
      return payload
    end

  end

  def extra_data(d, e)

    d << "temperature:#{e['temperature']},"
    d << "device_class:#{e['device_class']},"

    d << "color_mode:#{e['color_mode']},"
    d << "color_temp:#{e['color_temp']},"
    d << "white_value:#{e['white_value']},"

    v = e['hs_color'] || []
    d << "hue:#{v[0]},"
    d << "saturation:#{v[1]},"
    
    v = e['rgb_color'] || []
    d << "red:#{v[0]},"
    d << "green:#{v[1]},"
    d << "blue:#{v[2]},"
    
    v = e['xy_color'] || []
    d << "x_color:#{v[0]},"
    d << "y_color:#{v[1]},"
    d
  end

  def parse_event(js_data)
    case js_data['event_type']
    when 'state_changed'
      return parse_state(js_data['data'])
    when 'call_service'
      return parse_service(js_data['data'])
    else
      return [:unknown, js_data['event_type']]
    end
    
  end

  def parse_service(data)
    out = []
    a = data['service_data']
    s = data['service']
    m = data['domain']
    return [] unless a
    *entities = a['entity_id']
    entities.flatten.each do |e|
      next unless e
      d = ['type:call_service']
      d << "entity:#{e}"
      d << "service:#{s}"
      d << "domain:#{m}"
      out << d.join(',')
    end
    out
  end

  def from_string_with_key(k,st,out,key,depth=0)
    # $l.debug [:key, key, $filter.include?(key)]
    if $filter[0].downcase == 'all'
      return out if $filter.include?(key)
    else
      return out unless $filter.include?(key)
    end

    out << "#{depth}|#{k}|#{st}"

  end

  def from_array_with_key(k,a,out,depth=0)
    a.each_with_index do |v,key|
      wk = "#{k}|#{key}"
      if v.is_a?(Hash)
        out = from_hash_with_key(wk,v,out,depth+1)
      elsif v.is_a?(Array)
        out = from_array_with_key(wk,v,out,depth+1)
      else
        out = from_string_with_key(wk,v,out,key,depth)
      end
    end
    out
  end

  def from_hash_with_key(k,h,out,depth=0)
    h.each do |key,v|
      wk = "#{k}|#{key}"
      if v.is_a?(Hash)
        out = from_hash_with_key(wk,v,out,depth+1)
      elsif v.is_a?(Array)
        out = from_array_with_key(wk,v,out,depth+1)
      else
        out = from_string_with_key(wk,v,out,key,depth)
      end
    end
    out
  end

  def parse_state(*m)
    out = []
    return [] unless m[0]
    m.flatten.each do |e|
      ent = e['entity_id']
      from_hash_with_key(ent,e,out)
    end
    out
  end

  def parse_result(js_data)
    out = []
    *m = js_data['result']
    return [] unless m[0]
    m.flatten.each do |e|
      ent = e['entity_id']
      from_hash_with_key(ent,e,out)
    end
    out
  end
  
  private
  
  def send_text(json_data)
    message = json_data
    bytes = [129]
    size = message.bytesize
  
    bytes +=  if size <= 125
                [size]
              elsif size < 2**16
                [126] + [size].pack("n").bytes
              else
                [127] + [size].pack("Q>").bytes
              end
  
    bytes += message.bytes
    data = bytes.pack("C*")
    @id += 1
    self << data
  end
  
  def decomress(data)
    if @compression and data.size > 0
      # add trailer
      out = @zin.inflate(data << "\000\000\377\377")
    else
      return data
    end
  end

  def read_frame # methods https://github.com/mplatov/ruby-websocket-client
    b1 = read_nonblock(1)
    b1 = b1.unpack('C*')[0]
    fin = (b1 & 0b10000000) == 0b10000000
    opcode = (b1 & 0b00001111) 
    b2 = read_nonblock(1)
    b2 = b2.unpack('C*')[0]
    mask = (b2 & 0b10000000) # MASK bit 
      
    len = (b2 & 0b01111111)
    len = case len
      when 126
        b = read_nonblock(2)
        len = b.unpack('n*')[0]
      when 127
        b = read_nonblock(8)
        b.reverse! if !@big_endian
        len = b.unpack('Q')[0]
      else
        len
      end
    payload = read_nonblock(len)
    loop do 
      remain = len - payload.length
      # $l.debug [:payload_needed, len, :payload_got, payload.length, :remaining, remain]
      break unless remain > 0
      IO.select([self],nil,nil,10)
      payload << read_nonblock(remain)
    end
    return fin, opcode, payload
  end

  def hass_connect
    begin
      connect(@hass_addr)
    rescue IO::WaitWritable => e
      IO.select(nil, [self])
      begin
        connect(@hass_addr)
      rescue Errno::EISCONN => e
        sleep 1
        retry
      end
    end
  end
  
  def make_handshake
    [
      "GET /api/websocket HTTP/1.1",
      "Host: #{@hass_host}:#{@hass_port}",
      "Upgrade: websocket",
      "Connection: Upgrade",
      "Origin: #{@hass_address}",
      "Sec-WebSocket-Key: sWlwf7JEB0szCFezxzsejA==",
      "Sec-WebSocket-Version: 13"
    ].join("\r\n") << "\r\n\r\n"
  end
  
  def establish_websock(token)
    r = gets("\r\n\r\n")
    raise 'handshake error' unless r.include?('HTTP/1.1 101 Switching Protocols')
    send_text({type:'auth',access_token:token}.to_json)
    Thread.abort_on_exception = true
    Thread.new do
      loop do
        sleep 20
        ping
      end
    end
  end

  def ping
    send_text({
      id:@id,
      type:'ping'
    }.to_json)
  end

end

##########################################Helper Classes#####################################

class ProfileServer < Socket

  attr_reader :port, :socks, :lsof
  
  def initialize(port)
    super(AF_INET, SOCK_STREAM, 0)
    @port = port
    @socks = []
    @lsof = RUBY_PLATFORM.include?('linux') ? 'lsof' : '/usr/sbin/lsof'
    connect(local_ip, self, port)
  end
  
  def connect(addr, s, p)
    b = Socket.sockaddr_in(p, addr)
    s.setsockopt(:SOCKET, :REUSEADDR, true)
    s.bind(b)
    s.listen(5)
    @socket = s
  end
  
  def xfix(fix,type)
    return unless fix
    [fix.to_i(16)].pack('C') if type == 'hex'
  end
  
  def accept
    $l.debug "accepting profile connection on #{port}"
    s,info = accept_nonblock
    s.extend SocketMethods
    s.port = info.ip_port
    s.name = profile_name(info.ip_port)
    s.prefix = ''
    s.postfix = "\n"
    s.delimiter = "\n"
    $l.debug "new connection from #{s.name} on port #{port}"
    socks << s
  end
  
  def profile_name(port)
    pid = `#{@lsof} -i TCP:#{port} | grep avc`.match(/\s(\d+)\s/)[1]
    `ps -o command= -p #{pid}`.chop.split('avc ')[1]
  end
  
  def read_lines(socket)
    ready = IO.select(socks,nil,nil,READ_TIMEOUT)
    return unless ready
    ready[0].each do |s|
      m = s.next_line
      next unless m
      $l.debug m
      $l.debug "sent: #{socket.send_message(m)}"
    end
  end
  
  private
  
end

module SocketMethods

  attr_accessor :name, :port, :delimiter, :postfix, :prefix

  def inspect
    {name:name,port:port,pid:pid,delimiter:delimiter}.to_s
  end
  
  def puts_message(*msg)
    msg = msg.flatten
    # $l.debug [:writing,msg]
    msg.each do |m|
      print("#{prefix}#{"#{m}".gsub(postfix,'')}#{postfix}")
      sleep(0.01)
    end
  end

  def read_bytes(len)
    raise 'savant disconnected' if closed?
    read_nonblock(len)
  rescue IO::WaitReadable
    nil
  end

  def non_block_read
    loop do
      new_data = read_bytes 1024
      break unless new_data
      buf << new_data
      break if new_data.length < 1024
      # $l.debug buf
    end
  end

  def next_line
    @buf ||= ''
    # $l.debug buf.inspect
    non_block_read
    # $l.debug buf.inspect
    # $l.debug delimiter.inspect
    line = buf.slice!(/^.*#{delimiter}/)
    (line = line.chomp) || line
  end

  private

  attr_accessor :buf
end

# Code below is required for program startup. Modification is not recommended.

def local_ip
  return '0.0.0.0' if RUBY_PLATFORM == 'arm-linux-gnueabi'
  Socket.ip_address_list.to_s[/ ((?!127)\d\d?\d?\.[0-9]+\.[0-9]+\.[0-9]+)/,1]
end


def update_profile(env)
  `cp '#{env.profile_path}' '#{env.profile_home}'`
  IO.write(env.profile_path, IO.read(env.profile_home).gsub(/<\w[^!\n]+>\s*<!.._run_once_..>/,'').gsub(/<!-#{}-_run_after_(.+)-#{}->/,'\1'))
end

def install(env,port,serv)
  $l.debug 'Profile was updated. Process will restart'
  update_profile(env)
  sleep 1
  env.process_ids.each{|p| Process.kill('HUP',p)}
  sleep 1
  port
rescue => e
  $l.error [e,e.backtrace]
  exit
end

def uninstall(env)
 `rm '#{env.script_path}'`
 `rm '#{env.log_path}'`
  exit
end

class Environment

  attr_reader :profile_name, :profile_path, :script_path, :log_path, :home_path
  attr_reader :profiles_path, :rpm_path, :lock_path, :profile_home, :bp_names, :process_ids

  def initialize
    @profile_name = 'hass_ws'
    if RUBY_PLATFORM.include?('linux')
      @home_path = '/home/RPM/'
      @rpm_path = "#{home_path}GNUstep/Library/ApplicationSupport/RacePointMedia/"
      @scli ='/usr/local/bin/sclibridge'
    else
      @scli ='/Users/RPM/Applications/RacePointMedia/sclibridge'
      @home_path = '/Users/RPM/'
      @rpm_path = "#{home_path}Library/Application Support/RacePointMedia/"
    end
    @profiles_path = "#{rpm_path}userConfig.rpmConfig/componentProfiles/"
    @profile_path = "#{profiles_path}#{profile_name}.xml"
    @profile_home = "#{home_path}#{profile_name}.xml"
    @script_path = "#{home_path}#{profile_name}"
    @log_path = "#{home_path}#{profile_name}.log"
    
    find_component_names
    update_pids
    $l.debug [:names,@bp_names,:pids,@process_ids]
  end

  def find_component_names
    names = []
    str = "<string>#{@profile_name}</string>"
    r = `grep -lr -#{}-include "*.avc.plist" '#{str}' "#{@rpm_path}statusfiles"`
    names = r.chomp.split("\n").map{|s| s.split("/").last.split(".").first}
    raise "no components found using #{str}" if names.empty?
    @bp_names = names
  end
  
  def update_pids
    sleep 5
    pids = []
    @bp_names.each do |n|
      r = `ps ax -o pid= -o command= | grep -v grep | grep 'avc #{n}'`.to_i
      raise 'Savant System Still Loading. Sleeping' unless r > 0
      pids << r
    end
    @process_ids = pids
  rescue => e
    exit unless e.to_s.include? 'Loading'
    $l.error e
    sleep 5
    retry
  end

end

def connection_info(env)
  pattern = / po#{}rt="(\d+)".+proto#{}col="(\w+)"/
  `grep '<ip po#{}rt' "#{env.profile_path}"`.match(pattern).captures
end

t_server = ProfileServer.new(PORT)
Process.daemon

$l = Logger.new($stderr)
env = Environment.new
$l = Logger.new(env.log_path,1,1024000)
$l.level = Logger::WARN
$l.level = Logger::DEBUG if DEBUG
env = Environment.new
port, protocol = connection_info(env)
$l.debug "script started with #{protocol} on #{port}"
install(env,port.to_i,t_server) if protocol == 'udp'

$filter = ['brightness','state']

env.update_pids
sleep 5
`cp '#{env.profile_home}' '#{env.profile_path}'`
$l.debug 'replaced original profile'

begin
  program_loop(t_server)
rescue => e
  $l.error [:unhandled_exception_extiting,e,e.backtrace]
ensure
  $l.error [:killing, env.process_ids]
  env.process_ids.each{|p| Process.kill('HUP',p)}
end
#]]>-->
